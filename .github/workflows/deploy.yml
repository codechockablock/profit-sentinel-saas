name: Deploy

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      deploy_backend:
        description: 'Deploy backend to ECS'
        required: false
        default: true
        type: boolean
      deploy_frontend:
        description: 'Deploy frontend to Vercel'
        required: false
        default: true
        type: boolean

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: profitsentinel-dev-api
  ECS_CLUSTER: profitsentinel-dev-cluster
  ECS_SERVICE: profitsentinel-dev-api-service

jobs:
  # ===========================================================================
  # SECURITY CHECK - Verify no secrets in code
  # ===========================================================================
  security-check:
    name: Security Check
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Check for secrets in code
        run: |
          # Check for common secret patterns (excluding test files and mock values)
          # - AKIA... = AWS Access Key ID
          # - sk-... (48 chars) = OpenAI API Key
          # - xai-... (20+ chars) = xAI API Key (exclude short test values like "xai-key")
          if grep -rE '(AKIA[A-Z0-9]{16}|sk-[a-zA-Z0-9]{48}|xai-[a-zA-Z0-9]{20,})' \
            --include="*.py" --include="*.ts" --include="*.tsx" --include="*.js" \
            --exclude-dir="tests" --exclude-dir="__tests__" --exclude-dir="test" \
            --exclude="*test*.py" --exclude="*_test.py" --exclude="*spec.ts" \
            --exclude="conftest.py" \
            . 2>/dev/null; then
            echo "::error::Potential secrets found in code!"
            exit 1
          fi
          echo "Security check passed - no secrets found"

      - name: Verify .gitignore patterns
        run: |
          for pattern in ".env" "*.tfvars" "*.tfstate" "credentials.json"; do
            if ! grep -q "$pattern" .gitignore; then
              echo "::warning::Pattern '$pattern' not found in .gitignore"
            fi
          done
          echo "Gitignore verification complete"

  # ===========================================================================
  # BACKEND DEPLOYMENT - Docker build, ECR push, ECS update
  # ===========================================================================
  deploy-backend:
    name: Deploy Backend
    runs-on: ubuntu-latest
    needs: security-check
    if: |
      github.ref == 'refs/heads/main' &&
      (github.event_name == 'push' || github.event.inputs.deploy_backend == 'true')
    outputs:
      image_tag: ${{ steps.build.outputs.image_tag }}
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Fetch proprietary modules from private repo
        env:
          CORE_REPO_PAT: ${{ secrets.CORE_REPO_PAT }}
        run: |
          # Fetch core.py from private repository
          # This contains proprietary VSA detection logic
          if [ -n "$CORE_REPO_PAT" ]; then
            echo "Fetching proprietary modules from private repo..."

            # Clone the private repo (shallow, single file)
            git clone --depth 1 \
              https://${CORE_REPO_PAT}@github.com/codechockablock/profit-sentinel-core.git \
              /tmp/core-repo

            # Copy core.py to sentinel-engine package
            if [ -f /tmp/core-repo/core.py ]; then
              cp /tmp/core-repo/core.py packages/sentinel-engine/src/sentinel_engine/core.py
              echo "::notice::Proprietary core.py installed successfully"
            else
              echo "::warning::core.py not found in private repo, using heuristic fallback"
            fi

            # Cleanup
            rm -rf /tmp/core-repo
          else
            echo "::warning::CORE_REPO_PAT not configured, VSA engine will use heuristic fallback"
          fi

      - name: Build and push Docker image
        id: build
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          # Build with git commit SHA for traceability
          SHORT_SHA=$(echo $IMAGE_TAG | cut -c1-7)

          echo "Building image with tag: $SHORT_SHA"
          # Build from repo root with Dockerfile path specified
          # (Dockerfile expects access to packages/ for local dependencies)
          docker build \
            -f apps/api/Dockerfile \
            --build-arg BUILD_DATE=$(date -u +"%Y-%m-%dT%H:%M:%SZ") \
            --build-arg GIT_COMMIT=$IMAGE_TAG \
            -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
            -t $ECR_REGISTRY/$ECR_REPOSITORY:$SHORT_SHA \
            -t $ECR_REGISTRY/$ECR_REPOSITORY:latest \
            .

          echo "Pushing images to ECR..."
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$SHORT_SHA
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest

          echo "image_tag=$SHORT_SHA" >> $GITHUB_OUTPUT
          echo "::notice::Docker image pushed: $ECR_REGISTRY/$ECR_REPOSITORY:$SHORT_SHA"

      - name: Update ECS task definition with new image
        id: task-def
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          SHORT_SHA=$(echo $IMAGE_TAG | cut -c1-7)
          NEW_IMAGE="$ECR_REGISTRY/$ECR_REPOSITORY:$SHORT_SHA"

          echo "Updating task definition to use image: $NEW_IMAGE"

          # Get current task definition
          TASK_DEF=$(aws ecs describe-task-definition \
            --task-definition profitsentinel-dev-api \
            --query 'taskDefinition' \
            --output json)

          # Update the image in the container definition
          NEW_TASK_DEF=$(echo "$TASK_DEF" | jq --arg IMAGE "$NEW_IMAGE" \
            '.containerDefinitions[0].image = $IMAGE |
             del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)')

          # Register new task definition
          NEW_REVISION=$(aws ecs register-task-definition \
            --cli-input-json "$NEW_TASK_DEF" \
            --query 'taskDefinition.revision' \
            --output text)

          echo "Registered new task definition revision: $NEW_REVISION"
          echo "revision=$NEW_REVISION" >> $GITHUB_OUTPUT

      - name: Deploy to ECS
        run: |
          echo "Deploying task definition revision ${{ steps.task-def.outputs.revision }}..."
          aws ecs update-service \
            --cluster $ECS_CLUSTER \
            --service $ECS_SERVICE \
            --task-definition profitsentinel-dev-api:${{ steps.task-def.outputs.revision }} \
            --force-new-deployment \
            --query 'service.deployments[0].status' \
            --output text

          echo "::notice::ECS deployment initiated with new image for cluster: $ECS_CLUSTER"

      - name: Wait for ECS deployment stability
        run: |
          echo "Waiting for ECS service to stabilize (timeout: 5 minutes)..."
          aws ecs wait services-stable \
            --cluster $ECS_CLUSTER \
            --services $ECS_SERVICE \
            --timeout 300 || echo "::warning::ECS stability check timed out, manual verification recommended"

  # ===========================================================================
  # FRONTEND DEPLOYMENT - Vercel
  # ===========================================================================
  deploy-frontend:
    name: Deploy Frontend (Vercel)
    runs-on: ubuntu-latest
    needs: security-check
    if: |
      github.ref == 'refs/heads/main' &&
      (github.event_name == 'push' || github.event.inputs.deploy_frontend == 'true')
    outputs:
      deployment_url: ${{ steps.deploy.outputs.url }}
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: apps/web/package-lock.json

      - name: Install dependencies
        working-directory: apps/web
        run: npm ci

      - name: Run type check
        working-directory: apps/web
        run: npm run type-check || echo "::warning::Type check had issues"
        continue-on-error: true

      - name: Install Vercel CLI
        run: npm install -g vercel

      # Run Vercel commands from repo root - Vercel project has apps/web as root directory
      - name: Pull Vercel environment
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
        run: vercel pull --yes --environment=production --token=$VERCEL_TOKEN

      - name: Build for production
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
        run: vercel build --prod --token=$VERCEL_TOKEN

      - name: Deploy to Vercel
        id: deploy
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
          VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
          VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
        run: |
          DEPLOYMENT_URL=$(vercel deploy --prebuilt --prod --token=$VERCEL_TOKEN)
          echo "url=$DEPLOYMENT_URL" >> $GITHUB_OUTPUT
          echo "::notice::Frontend deployed to: $DEPLOYMENT_URL"

  # ===========================================================================
  # POST-DEPLOYMENT HEALTH CHECKS
  # ===========================================================================
  health-check:
    name: Health Check
    runs-on: ubuntu-latest
    needs: [deploy-backend, deploy-frontend]
    if: always() && (needs.deploy-backend.result == 'success' || needs.deploy-frontend.result == 'success')
    steps:
      - name: Check backend health
        if: needs.deploy-backend.result == 'success'
        run: |
          echo "Waiting 30 seconds for ECS tasks to start..."
          sleep 30

          # Get ALB DNS from Terraform output or use configured domain
          # For now, we'll just note that manual verification is needed
          echo "::notice::Backend deployment complete. Verify health at your API endpoint: /health"

      - name: Verify frontend deployment
        if: needs.deploy-frontend.result == 'success'
        run: |
          FRONTEND_URL="${{ needs.deploy-frontend.outputs.deployment_url }}"
          if [ -n "$FRONTEND_URL" ]; then
            echo "Testing frontend at: $FRONTEND_URL"
            HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$FRONTEND_URL" || echo "000")
            if [ "$HTTP_STATUS" = "200" ]; then
              echo "::notice::Frontend health check passed (HTTP $HTTP_STATUS)"
            else
              echo "::warning::Frontend returned HTTP $HTTP_STATUS"
            fi
          fi

  # ===========================================================================
  # DEPLOYMENT SUMMARY
  # ===========================================================================
  notify:
    name: Deployment Summary
    runs-on: ubuntu-latest
    needs: [deploy-backend, deploy-frontend, health-check]
    if: always()
    steps:
      - name: Generate deployment summary
        run: |
          echo "## Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Component | Status | Details |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|--------|---------|" >> $GITHUB_STEP_SUMMARY

          # Backend status
          if [ "${{ needs.deploy-backend.result }}" == "success" ]; then
            echo "| Backend | :white_check_mark: Success | Image: \`${{ needs.deploy-backend.outputs.image_tag }}\` |" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ needs.deploy-backend.result }}" == "skipped" ]; then
            echo "| Backend | :fast_forward: Skipped | - |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| Backend | :x: Failed | Check logs |" >> $GITHUB_STEP_SUMMARY
          fi

          # Frontend status
          if [ "${{ needs.deploy-frontend.result }}" == "success" ]; then
            echo "| Frontend | :white_check_mark: Success | ${{ needs.deploy-frontend.outputs.deployment_url }} |" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ needs.deploy-frontend.result }}" == "skipped" ]; then
            echo "| Frontend | :fast_forward: Skipped | - |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| Frontend | :x: Failed | Check logs |" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Git Commit:** \`${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Triggered by:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "**Workflow run:** [View details](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})" >> $GITHUB_STEP_SUMMARY

      - name: Report final status
        run: |
          BACKEND="${{ needs.deploy-backend.result }}"
          FRONTEND="${{ needs.deploy-frontend.result }}"

          if [ "$BACKEND" == "success" ] && [ "$FRONTEND" == "success" ]; then
            echo "::notice::All deployments successful!"
          elif [ "$BACKEND" == "success" ] || [ "$FRONTEND" == "success" ]; then
            echo "::warning::Partial deployment - check individual job results"
          elif [ "$BACKEND" == "skipped" ] && [ "$FRONTEND" == "skipped" ]; then
            echo "::notice::No deployments were triggered"
          else
            echo "::error::Deployment failed - check logs for details"
          fi
